[CacheAgentState(node=NodeInfo(type='Class', name='DBRole', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBRole:\n    """Defines constants for database roles to ensure type safety."""\n    WRITE = "write"\n    READ = "read"'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='create_database', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def create_database(write_url: str, read_url: str = None, **engine_kwargs) -> DBHandle:\n    """\n    Creates database engines and returns a handle.\n\n    This function uses SQLAlchemy\'s automap feature to reflect the database schema.\n    To connect to MySQL, you might need to install a driver like PyMySQL:\n    \'pip install pymysql\'\n    And format your URL like: \'mysql+pymysql://user:pass@host/db\'\n\n    Args:\n        write_url (str): The connection string for the primary (write) database.\n        read_url (str, optional): The connection string for the read replica. Defaults to None.\n        **engine_kwargs: Additional arguments for the SQLAlchemy create_engine function,\n                         e.g., pool_recycle=3600.\n\n    Returns:\n        DBHandle: A handle containing the database engines and mapped base.\n    """\n    # Default pool_recycle to 1800 seconds (30 minutes) if not specified\n    engine_kwargs.setdefault(\'pool_recycle\', 1800)\n\n    # The write engine is the source of truth for schema reflection\n    write_engine = create_engine(write_url, **engine_kwargs)\n    \n    read_engine = None\n    if read_url:\n        read_engine = create_engine(read_url, **engine_kwargs)\n\n    # Reflect the database schema from the write engine\n    Base = automap_base()\n    Base.prepare(autoload_with=write_engine, reflect=True)\n\n    return DBHandle(write_engine, Base, read_engine)'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='list_all_table_names', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._base.classes.keys())'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='get_table_class', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='execute_sql_from_file', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py', code_content='def __init__(self, session):\n        self.session = session'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='select', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py', code_content='def select(self, cls, filters=None, order_by=None, offset=None, limit=None, join=None):\n        if filters is None:\n            filters = []\n        if not isinstance(filters, list):\n            filters = [filters]\n\n        query = self.session.query(cls).filter(*filters)\n        if order_by is not None:\n            query = query.order_by(order_by)\n        if join is not None:\n            query = query.join(join)\n        if offset:\n            query = query.offset(offset)\n        if limit:\n            query = query.limit(limit)\n        return query'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def __init__(self,  job_id, component_id, sub_component_id, event_code,\n                    event_description=None, event_data=None, version=None):\n        self.job_id:int = job_id\n        self.component_id= component_id\n        self.sub_component_id = sub_component_id\n        self.event_code = event_code\n        self.event_description = event_description\n        self.event_data = event_data\n        self.version = version'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='addContext_kv', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def addContext_kv(self, key, value):\n        self.event_data[key] = value'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='to_dict', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content="def to_dict(self):\n        return {\n            'job_id': self.job_id,\n            'component_id': self.component_id,\n            'sub_component_id': self.sub_component_id,\n            'event_code': self.event_code,\n            'event_description': self.event_description,\n            'event_data': self.event_data,\n            'version': self.version\n        }"), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='__str__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def __str__(self):\n        return (f"AmlEvent(job_id={self.job_id}, component_id={self.component_id}, "\n                f"sub_component_id={self.sub_component_id}, event_code={self.event_code}, "\n                f"event_description={self.event_description}, event_data={self.event_data}, "\n                f"version={self.version})")'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def __init__(self, db_handle):\n        super(AmlEventClient, self).__init__(db_handle)'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='_object_as_dict', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def _object_as_dict(obj):\n        obj_dict = {}\n        for column in inspect(obj).mapper.column_attrs:\n            key = column.key\n            value = getattr(obj, column.key)\n            if isinstance(value, datetime.datetime):\n                value = value.strftime("%Y-%m-%d %H:%M:%S")\n            obj_dict[key] = value\n        return obj_dict'), dependencies=[]), CacheAgentState(node=NodeInfo(type='Function', name='session_scope', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)'), dependencies=[NodeInfo(type='Class', name='DBRole', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBRole:\n    """Defines constants for database roles to ensure type safety."""\n    WRITE = "write"\n    READ = "read"')]), CacheAgentState(node=NodeInfo(type='Class', name='DBHandle', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBHandle:\n    """A handle that holds the configured database engines and reflected base class."""\n    def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)'), dependencies=[NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)')]), CacheAgentState(node=NodeInfo(type='Class', name='DBClient', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py', code_content='class DBClient(object):\n    def __init__(self, session):\n        self.session = session\n\n    def select(self, cls, filters=None, order_by=None, offset=None, limit=None, join=None):\n        if filters is None:\n            filters = []\n        if not isinstance(filters, list):\n            filters = [filters]\n\n        query = self.session.query(cls).filter(*filters)\n        if order_by is not None:\n            query = query.order_by(order_by)\n        if join is not None:\n            query = query.join(join)\n        if offset:\n            query = query.offset(offset)\n        if limit:\n            query = query.limit(limit)\n        return query'), dependencies=[NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py', code_content='def __init__(self, session):\n        self.session = session'), NodeInfo(type='Function', name='select', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py', code_content='def select(self, cls, filters=None, order_by=None, offset=None, limit=None, join=None):\n        if filters is None:\n            filters = []\n        if not isinstance(filters, list):\n            filters = [filters]\n\n        query = self.session.query(cls).filter(*filters)\n        if order_by is not None:\n            query = query.order_by(order_by)\n        if join is not None:\n            query = query.join(join)\n        if offset:\n            query = query.offset(offset)\n        if limit:\n            query = query.limit(limit)\n        return query')]), CacheAgentState(node=NodeInfo(type='Class', name='AmlEvent', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='class AmlEvent:\n    def __init__(self,  job_id, component_id, sub_component_id, event_code,\n                    event_description=None, event_data=None, version=None):\n        self.job_id:int = job_id\n        self.component_id= component_id\n        self.sub_component_id = sub_component_id\n        self.event_code = event_code\n        self.event_description = event_description\n        self.event_data = event_data\n        self.version = version\n\n    def addContext_kv(self, key, value):\n        self.event_data[key] = value\n    \n    def to_dict(self):\n        return {\n            \'job_id\': self.job_id,\n            \'component_id\': self.component_id,\n            \'sub_component_id\': self.sub_component_id,\n            \'event_code\': self.event_code,\n            \'event_description\': self.event_description,\n            \'event_data\': self.event_data,\n            \'version\': self.version\n        }\n    \n    def __str__(self):\n        return (f"AmlEvent(job_id={self.job_id}, component_id={self.component_id}, "\n                f"sub_component_id={self.sub_component_id}, event_code={self.event_code}, "\n                f"event_description={self.event_description}, event_data={self.event_data}, "\n                f"version={self.version})")'), dependencies=[NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def __init__(self,  job_id, component_id, sub_component_id, event_code,\n                    event_description=None, event_data=None, version=None):\n        self.job_id:int = job_id\n        self.component_id= component_id\n        self.sub_component_id = sub_component_id\n        self.event_code = event_code\n        self.event_description = event_description\n        self.event_data = event_data\n        self.version = version'), NodeInfo(type='Function', name='addContext_kv', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def addContext_kv(self, key, value):\n        self.event_data[key] = value'), NodeInfo(type='Function', name='to_dict', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content="def to_dict(self):\n        return {\n            'job_id': self.job_id,\n            'component_id': self.component_id,\n            'sub_component_id': self.sub_component_id,\n            'event_code': self.event_code,\n            'event_description': self.event_description,\n            'event_data': self.event_data,\n            'version': self.version\n        }"), NodeInfo(type='Function', name='__str__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def __str__(self):\n        return (f"AmlEvent(job_id={self.job_id}, component_id={self.component_id}, "\n                f"sub_component_id={self.sub_component_id}, event_code={self.event_code}, "\n                f"event_description={self.event_description}, event_data={self.event_data}, "\n                f"version={self.version})")')]), CacheAgentState(node=NodeInfo(type='Class', name='DatabaseManager', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DatabaseManager:\n    """\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    """\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise'), dependencies=[NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls'), NodeInfo(type='Function', name='list_all_table_names', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._base.classes.keys())'), NodeInfo(type='Function', name='get_table_class', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)'), NodeInfo(type='Function', name='session_scope', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)'), NodeInfo(type='Function', name='execute_sql_from_file', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise')]), CacheAgentState(node=NodeInfo(type='Function', name='insert_event', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def insert_event(self, job_id, component_id, sub_component_id, event_code,\n                    event_description=None,event_data=None, version=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                event = AmlEventPool()\n                event.job_id = job_id\n                event.component_id = component_id\n                event.sub_component_id = sub_component_id\n                event.event_code = event_code\n                event.event_description = event_description\n                event.event_data = json.dumps(event_data or {})\n                event.version = version\n                event.created_at = datetime.datetime.now()\n                event.updated_at = datetime.datetime.now()\n                event.version = version\n                session.add(event)\n                session.commit()\n                return job_id if job_id else event.id, ""\n            except Exception as e:\n                err_msg = "insert event error: {}".format(repr(e))\n                logging.error(err_msg)\n                return 0, err_msg'), dependencies=[NodeInfo(type='Class', name='DBHandle', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBHandle:\n    """A handle that holds the configured database engines and reflected base class."""\n    def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)'), NodeInfo(type='Class', name='DatabaseManager', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DatabaseManager:\n    """\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    """\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise')]), CacheAgentState(node=NodeInfo(type='Function', name='query_events', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def query_events(self, query_dict=None, query_by_desc=False, limit=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        query_dict = query_dict or {}\n        with self._session_scope() as session:\n            try:\n                matched_event_list = []\n                filters = []\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in query_dict and query_dict[column.name] is not None:\n                        if column.name in ["created_at", "updated_at"]:\n                            filters.append(and_(column > query_dict[column.name]))\n                        else:\n                            filters.append(and_(column == query_dict[column.name]))\n                query = DBClient(session).select(AmlEventPool, filters)\n                if query_by_desc:\n                    query = query.order_by(desc(AmlEventPool.job_id))\n                if limit:\n                    query = query.limit(limit)\n                for res in query:\n                    matched_event_list.append(self._object_as_dict(res))\n                return matched_event_list\n            except Exception as e:\n                logging.error("query event error: {}".format(repr(e)))\n                return None'), dependencies=[NodeInfo(type='Class', name='DBHandle', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBHandle:\n    """A handle that holds the configured database engines and reflected base class."""\n    def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)'), NodeInfo(type='Class', name='DatabaseManager', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DatabaseManager:\n    """\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    """\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise')]), CacheAgentState(node=NodeInfo(type='Function', name='update_event', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def update_event(self, id, job_id, **kwargs):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                job = session.query(AmlEventPool)\\\n                        .filter(AmlEventPool.id == id)\\\n                        .filter(AmlEventPool.job_id == job_id)\\\n                        .one()\n                job.updated_at = datetime.datetime.now()\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in kwargs and kwargs[column.name] is not None:\n                        setattr(job, column.name, kwargs[column.name])\n                session.add(job)\n                session.commit()\n                return True, ""\n            except Exception as e:\n                err_msg = "update job error: {}".format(repr(e))\n                logging.error(err_msg)\n                return False, err_msg'), dependencies=[NodeInfo(type='Class', name='DBHandle', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBHandle:\n    """A handle that holds the configured database engines and reflected base class."""\n    def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)'), NodeInfo(type='Class', name='DatabaseManager', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DatabaseManager:\n    """\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    """\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise')]), CacheAgentState(node=NodeInfo(type='Function', name='reset_database', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def reset_database(self):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                session.query(AmlEventPool).delete()\n                session.commit()\n                print("All job should be deleted")\n                return True\n            except Exception as e:\n                err_msg = f"fail to delete {e}"\n                print(err_msg)\n                return False'), dependencies=[NodeInfo(type='Class', name='DBHandle', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DBHandle:\n    """A handle that holds the configured database engines and reflected base class."""\n    def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info("DBHandle created. Write Engine: %s, Read Engine: %s", write_engine.url, self.read_engine.url)'), NodeInfo(type='Class', name='DatabaseManager', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DatabaseManager:\n    """\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    """\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise')]), CacheAgentState(node=NodeInfo(type='Class', name='AmlEventClient', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='class AmlEventClient(DatabaseManager):\n    def __init__(self, db_handle):\n        super(AmlEventClient, self).__init__(db_handle)\n\n    @staticmethod\n    def _object_as_dict(obj):\n        obj_dict = {}\n        for column in inspect(obj).mapper.column_attrs:\n            key = column.key\n            value = getattr(obj, column.key)\n            if isinstance(value, datetime.datetime):\n                value = value.strftime("%Y-%m-%d %H:%M:%S")\n            obj_dict[key] = value\n        return obj_dict\n\n    def insert_event(self, job_id, component_id, sub_component_id, event_code,\n                    event_description=None,event_data=None, version=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                event = AmlEventPool()\n                event.job_id = job_id\n                event.component_id = component_id\n                event.sub_component_id = sub_component_id\n                event.event_code = event_code\n                event.event_description = event_description\n                event.event_data = json.dumps(event_data or {})\n                event.version = version\n                event.created_at = datetime.datetime.now()\n                event.updated_at = datetime.datetime.now()\n                event.version = version\n                session.add(event)\n                session.commit()\n                return job_id if job_id else event.id, ""\n            except Exception as e:\n                err_msg = "insert event error: {}".format(repr(e))\n                logging.error(err_msg)\n                return 0, err_msg\n\n    def query_events(self, query_dict=None, query_by_desc=False, limit=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        query_dict = query_dict or {}\n        with self._session_scope() as session:\n            try:\n                matched_event_list = []\n                filters = []\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in query_dict and query_dict[column.name] is not None:\n                        if column.name in ["created_at", "updated_at"]:\n                            filters.append(and_(column > query_dict[column.name]))\n                        else:\n                            filters.append(and_(column == query_dict[column.name]))\n                query = DBClient(session).select(AmlEventPool, filters)\n                if query_by_desc:\n                    query = query.order_by(desc(AmlEventPool.job_id))\n                if limit:\n                    query = query.limit(limit)\n                for res in query:\n                    matched_event_list.append(self._object_as_dict(res))\n                return matched_event_list\n            except Exception as e:\n                logging.error("query event error: {}".format(repr(e)))\n                return None\n\n    def update_event(self, id, job_id, **kwargs):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                job = session.query(AmlEventPool)\\\n                        .filter(AmlEventPool.id == id)\\\n                        .filter(AmlEventPool.job_id == job_id)\\\n                        .one()\n                job.updated_at = datetime.datetime.now()\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in kwargs and kwargs[column.name] is not None:\n                        setattr(job, column.name, kwargs[column.name])\n                session.add(job)\n                session.commit()\n                return True, ""\n            except Exception as e:\n                err_msg = "update job error: {}".format(repr(e))\n                logging.error(err_msg)\n                return False, err_msg\n            \n    def reset_database(self):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                session.query(AmlEventPool).delete()\n                session.commit()\n                print("All job should be deleted")\n                return True\n            except Exception as e:\n                err_msg = f"fail to delete {e}"\n                print(err_msg)\n                return False'), dependencies=[NodeInfo(type='Function', name='__init__', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def __init__(self, db_handle):\n        super(AmlEventClient, self).__init__(db_handle)'), NodeInfo(type='Function', name='_object_as_dict', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def _object_as_dict(obj):\n        obj_dict = {}\n        for column in inspect(obj).mapper.column_attrs:\n            key = column.key\n            value = getattr(obj, column.key)\n            if isinstance(value, datetime.datetime):\n                value = value.strftime("%Y-%m-%d %H:%M:%S")\n            obj_dict[key] = value\n        return obj_dict'), NodeInfo(type='Function', name='insert_event', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def insert_event(self, job_id, component_id, sub_component_id, event_code,\n                    event_description=None,event_data=None, version=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                event = AmlEventPool()\n                event.job_id = job_id\n                event.component_id = component_id\n                event.sub_component_id = sub_component_id\n                event.event_code = event_code\n                event.event_description = event_description\n                event.event_data = json.dumps(event_data or {})\n                event.version = version\n                event.created_at = datetime.datetime.now()\n                event.updated_at = datetime.datetime.now()\n                event.version = version\n                session.add(event)\n                session.commit()\n                return job_id if job_id else event.id, ""\n            except Exception as e:\n                err_msg = "insert event error: {}".format(repr(e))\n                logging.error(err_msg)\n                return 0, err_msg'), NodeInfo(type='Function', name='query_events', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def query_events(self, query_dict=None, query_by_desc=False, limit=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        query_dict = query_dict or {}\n        with self._session_scope() as session:\n            try:\n                matched_event_list = []\n                filters = []\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in query_dict and query_dict[column.name] is not None:\n                        if column.name in ["created_at", "updated_at"]:\n                            filters.append(and_(column > query_dict[column.name]))\n                        else:\n                            filters.append(and_(column == query_dict[column.name]))\n                query = DBClient(session).select(AmlEventPool, filters)\n                if query_by_desc:\n                    query = query.order_by(desc(AmlEventPool.job_id))\n                if limit:\n                    query = query.limit(limit)\n                for res in query:\n                    matched_event_list.append(self._object_as_dict(res))\n                return matched_event_list\n            except Exception as e:\n                logging.error("query event error: {}".format(repr(e)))\n                return None'), NodeInfo(type='Function', name='update_event', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def update_event(self, id, job_id, **kwargs):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                job = session.query(AmlEventPool)\\\n                        .filter(AmlEventPool.id == id)\\\n                        .filter(AmlEventPool.job_id == job_id)\\\n                        .one()\n                job.updated_at = datetime.datetime.now()\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in kwargs and kwargs[column.name] is not None:\n                        setattr(job, column.name, kwargs[column.name])\n                session.add(job)\n                session.commit()\n                return True, ""\n            except Exception as e:\n                err_msg = "update job error: {}".format(repr(e))\n                logging.error(err_msg)\n                return False, err_msg'), NodeInfo(type='Function', name='reset_database', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py', code_content='def reset_database(self):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                session.query(AmlEventPool).delete()\n                session.commit()\n                print("All job should be deleted")\n                return True\n            except Exception as e:\n                err_msg = f"fail to delete {e}"\n                print(err_msg)\n                return False'), NodeInfo(type='Class', name='DatabaseManager', path='/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py', code_content='class DatabaseManager:\n    """\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    """\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        """Returns a list of all table names discovered in the database schema."""\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        """\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        """\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        """\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        """\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f"Unknown database role: {role}")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info("Session created for role: %s", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error("Session rollback due to an exception: %s", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info("Session closed for role: %s", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        """\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        """\n        if not file_path.endswith(\'.sql\'):\n            raise ValueError("File must be a .sql file.")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"SQL file not found at: {file_path}")\n\n        with open(file_path, "r") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don\'t support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info("Successfully executed SQL from %s", file_path)\n            except Exception as e:\n                logging.error("Error executing %s: %s", file_path, e)\n                raise')])]