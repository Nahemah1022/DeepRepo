[
  {
    "index": 0, 
    "type": "Class",
    "name": "DBRole",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "class DBRole:\n    \"\"\"Defines constants for database roles to ensure type safety.\"\"\"\n    WRITE = \"write\"\n    READ = \"read\"",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 1, 
    "type": "Class",
    "name": "DBHandle",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "class DBHandle:\n    \"\"\"A handle that holds the configured database engines and reflected base class.\"\"\"\n    def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info(\"DBHandle created. Write Engine: %s, Read Engine: %s\", write_engine.url, self.read_engine.url)",
    "dependencies_count": 1,
    "dependencies": [2]
  },
  { 
    "index":2,
    "type": "Function",
    "name": "__init__",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def __init__(self, write_engine, base_cls, read_engine=None):\n        self.write_engine = write_engine\n        # If no read engine is provided, read operations will use the write engine.\n        self.read_engine = read_engine or write_engine\n        self.base_cls = base_cls\n        logging.info(\"DBHandle created. Write Engine: %s, Read Engine: %s\", write_engine.url, self.read_engine.url)",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 3,
    "type": "Function",
    "name": "create_database",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def create_database(write_url: str, read_url: str = None, **engine_kwargs) -> DBHandle:\n    \"\"\"\n    Creates database engines and returns a handle.\n\n    This function uses SQLAlchemy's automap feature to reflect the database schema.\n    To connect to MySQL, you might need to install a driver like PyMySQL:\n    'pip install pymysql'\n    And format your URL like: 'mysql+pymysql://user:pass@host/db'\n\n    Args:\n        write_url (str): The connection string for the primary (write) database.\n        read_url (str, optional): The connection string for the read replica. Defaults to None.\n        **engine_kwargs: Additional arguments for the SQLAlchemy create_engine function,\n                         e.g., pool_recycle=3600.\n\n    Returns:\n        DBHandle: A handle containing the database engines and mapped base.\n    \"\"\"\n    # Default pool_recycle to 1800 seconds (30 minutes) if not specified\n    engine_kwargs.setdefault('pool_recycle', 1800)\n\n    # The write engine is the source of truth for schema reflection\n    write_engine = create_engine(write_url, **engine_kwargs)\n    \n    read_engine = None\n    if read_url:\n        read_engine = create_engine(read_url, **engine_kwargs)\n\n    # Reflect the database schema from the write engine\n    Base = automap_base()\n    Base.prepare(autoload_with=write_engine, reflect=True)\n\n    return DBHandle(write_engine, Base, read_engine)",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 4,
    "type": "Class",
    "name": "DatabaseManager",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "class DatabaseManager:\n    \"\"\"\n    Provides a high-level API for interacting with the database.\n    Manages sessions and executes SQL operations.\n    \"\"\"\n    def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls\n\n    def list_all_table_names(self) -> list:\n        \"\"\"Returns a list of all table names discovered in the database schema.\"\"\"\n        return list(self._Base.classes.keys())\n\n    def get_table_class(self, table_name: str):\n        \"\"\"\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        \"\"\"\n        return self._base.classes.get(table_name)\n\n    @contextmanager\n    def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        \"\"\"\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        \"\"\"\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f\"Unknown database role: {role}\")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info(\"Session created for role: %s\", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error(\"Session rollback due to an exception: %s\", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info(\"Session closed for role: %s\", role)\n\n    def execute_sql_from_file(self, file_path: str):\n        \"\"\"\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        \"\"\"\n        if not file_path.endswith('.sql'):\n            raise ValueError(\"File must be a .sql file.\")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f\"SQL file not found at: {file_path}\")\n\n        with open(file_path, \"r\") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don't support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info(\"Successfully executed SQL from %s\", file_path)\n            except Exception as e:\n                logging.error(\"Error executing %s: %s\", file_path, e)\n                raise",
    "dependencies_count": 5,
    "dependencies": [5,6,7,8,9]
  },
  {
    "index": 5,
    "type": "Function",
    "name": "__init__",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def __init__(self, db_handle: DBHandle):\n        self._db_handle = db_handle\n        self._write_engine = db_handle.write_engine\n        self._read_engine = db_handle.read_engine\n        self._base = db_handle.base_cls",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 6,
    "type": "Function",
    "name": "list_all_table_names",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def list_all_table_names(self) -> list:\n        \"\"\"Returns a list of all table names discovered in the database schema.\"\"\"\n        return list(self._base.classes.keys())",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 7,
    "type": "Function",
    "name": "get_table_class",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def get_table_class(self, table_name: str):\n        \"\"\"\n        Returns the mapped class for a given table name.\n\n        Args:\n            table_name (str): The name of the table.\n\n        Returns:\n            The SQLAlchemy mapped class, or None if not found.\n        \"\"\"\n        return self._base.classes.get(table_name)",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 8,
    "type": "Function",
    "name": "session_scope",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def session_scope(self, role: str = DBRole.WRITE) -> Session:\n        \"\"\"\n        Provides a transactional scope around a series of operations.\n        This context manager handles session creation, commit, rollback, and closing.\n\n        Args:\n            role (str): The database role, either DBRole.WRITE or DBRole.READ.\n\n        Yields:\n            Session: The SQLAlchemy session object.\n        \"\"\"\n        if role == DBRole.WRITE:\n            engine = self._write_engine\n        elif role == DBRole.READ:\n            engine = self._read_engine\n        else:\n            raise ValueError(f\"Unknown database role: {role}\")\n\n        session = sessionmaker(bind=engine, autoflush=False)()\n        logging.info(\"Session created for role: %s\", role)\n        \n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            logging.error(\"Session rollback due to an exception: %s\", e)\n            session.rollback()\n            raise\n        finally:\n            session.close()\n            logging.info(\"Session closed for role: %s\", role)",
    "dependencies_count": 1,
    "dependencies": [0]
  },
  {
    "index": 9,
    "type": "Function",
    "name": "execute_sql_from_file",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/main_db.py",
    "code_content": "def execute_sql_from_file(self, file_path: str):\n        \"\"\"\n        Executes all SQL statements from a given .sql file.\n        \n        Note: This is for schema changes or bulk operations and runs outside a session transaction.\n        \"\"\"\n        if not file_path.endswith('.sql'):\n            raise ValueError(\"File must be a .sql file.\")\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f\"SQL file not found at: {file_path}\")\n\n        with open(file_path, \"r\") as file:\n            sql_script = file.read()\n            try:\n                # Use the write engine for executing schema changes or data loads\n                with self._write_engine.connect() as connection:\n                    connection.execute(text(sql_script))\n                    # For engines that don't support autocommit on DDL\n                    if connection.dialect.supports_alter:\n                        connection.commit()\n                logging.info(\"Successfully executed SQL from %s\", file_path)\n            except Exception as e:\n                logging.error(\"Error executing %s: %s\", file_path, e)\n                raise",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 10,
    "type": "Class",
    "name": "DBClient",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py",
    "code_content": "class DBClient(object):\n    def __init__(self, session):\n        self.session = session\n\n    def select(self, cls, filters=None, order_by=None, offset=None, limit=None, join=None):\n        if filters is None:\n            filters = []\n        if not isinstance(filters, list):\n            filters = [filters]\n\n        query = self.session.query(cls).filter(*filters)\n        if order_by is not None:\n            query = query.order_by(order_by)\n        if join is not None:\n            query = query.join(join)\n        if offset:\n            query = query.offset(offset)\n        if limit:\n            query = query.limit(limit)\n        return query",
    "dependencies_count": 2,
    "dependencies": [11,12]
  },
  {
    "index": 11,
    "type": "Function",
    "name": "__init__",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py",
    "code_content": "def __init__(self, session):\n        self.session = session",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 12,
    "type": "Function",
    "name": "select",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/db_client.py",
    "code_content": "def select(self, cls, filters=None, order_by=None, offset=None, limit=None, join=None):\n        if filters is None:\n            filters = []\n        if not isinstance(filters, list):\n            filters = [filters]\n\n        query = self.session.query(cls).filter(*filters)\n        if order_by is not None:\n            query = query.order_by(order_by)\n        if join is not None:\n            query = query.join(join)\n        if offset:\n            query = query.offset(offset)\n        if limit:\n            query = query.limit(limit)\n        return query",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 13,
    "type": "Class",
    "name": "AmlEvent",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "class AmlEvent:\n    def __init__(self,  job_id, component_id, sub_component_id, event_code,\n                    event_description=None, event_data=None, version=None):\n        self.job_id:int = job_id\n        self.component_id= component_id\n        self.sub_component_id = sub_component_id\n        self.event_code = event_code\n        self.event_description = event_description\n        self.event_data = event_data\n        self.version = version\n\n    def addContext_kv(self, key, value):\n        self.event_data[key] = value\n    \n    def to_dict(self):\n        return {\n            'job_id': self.job_id,\n            'component_id': self.component_id,\n            'sub_component_id': self.sub_component_id,\n            'event_code': self.event_code,\n            'event_description': self.event_description,\n            'event_data': self.event_data,\n            'version': self.version\n        }\n    \n    def __str__(self):\n        return (f\"AmlEvent(job_id={self.job_id}, component_id={self.component_id}, \"\n                f\"sub_component_id={self.sub_component_id}, event_code={self.event_code}, \"\n                f\"event_description={self.event_description}, event_data={self.event_data}, \"\n                f\"version={self.version})\")",
    "dependencies_count": 4,
    "dependencies": [14,15,16,17]
  },
  {
    "index": 14,
    "type": "Function",
    "name": "__init__",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def __init__(self,  job_id, component_id, sub_component_id, event_code,\n                    event_description=None, event_data=None, version=None):\n        self.job_id:int = job_id\n        self.component_id= component_id\n        self.sub_component_id = sub_component_id\n        self.event_code = event_code\n        self.event_description = event_description\n        self.event_data = event_data\n        self.version = version",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 15,
    "type": "Function",
    "name": "addContext_kv",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def addContext_kv(self, key, value):\n        self.event_data[key] = value",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 16,
    "type": "Function",
    "name": "to_dict",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def to_dict(self):\n        return {\n            'job_id': self.job_id,\n            'component_id': self.component_id,\n            'sub_component_id': self.sub_component_id,\n            'event_code': self.event_code,\n            'event_description': self.event_description,\n            'event_data': self.event_data,\n            'version': self.version\n        }",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 17,
    "type": "Function",
    "name": "__str__",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def __str__(self):\n        return (f\"AmlEvent(job_id={self.job_id}, component_id={self.component_id}, \"\n                f\"sub_component_id={self.sub_component_id}, event_code={self.event_code}, \"\n                f\"event_description={self.event_description}, event_data={self.event_data}, \"\n                f\"version={self.version})\")",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 18,
    "type": "Class",
    "name": "AmlEventClient",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "class AmlEventClient(DatabaseManager):\n    def __init__(self, db_handle):\n        super(AmlEventClient, self).__init__(db_handle)\n\n    @staticmethod\n    def _object_as_dict(obj):\n        obj_dict = {}\n        for column in inspect(obj).mapper.column_attrs:\n            key = column.key\n            value = getattr(obj, column.key)\n            if isinstance(value, datetime.datetime):\n                value = value.strftime(\"%Y-%m-%d %H:%M:%S\")\n            obj_dict[key] = value\n        return obj_dict\n\n    def insert_event(self, job_id, component_id, sub_component_id, event_code,\n                    event_description=None,event_data=None, version=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                event = AmlEventPool()\n                event.job_id = job_id\n                event.component_id = component_id\n                event.sub_component_id = sub_component_id\n                event.event_code = event_code\n                event.event_description = event_description\n                event.event_data = json.dumps(event_data or {})\n                event.version = version\n                event.created_at = datetime.datetime.now()\n                event.updated_at = datetime.datetime.now()\n                event.version = version\n                session.add(event)\n                session.commit()\n                return job_id if job_id else event.id, \"\"\n            except Exception as e:\n                err_msg = \"insert event error: {}\".format(repr(e))\n                logging.error(err_msg)\n                return 0, err_msg\n\n    def query_events(self, query_dict=None, query_by_desc=False, limit=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        query_dict = query_dict or {}\n        with self._session_scope() as session:\n            try:\n                matched_event_list = []\n                filters = []\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in query_dict and query_dict[column.name] is not None:\n                        if column.name in [\"created_at\", \"updated_at\"]:\n                            filters.append(and_(column > query_dict[column.name]))\n                        else:\n                            filters.append(and_(column == query_dict[column.name]))\n                query = DBClient(session).select(AmlEventPool, filters)\n                if query_by_desc:\n                    query = query.order_by(desc(AmlEventPool.job_id))\n                if limit:\n                    query = query.limit(limit)\n                for res in query:\n                    matched_event_list.append(self._object_as_dict(res))\n                return matched_event_list\n            except Exception as e:\n                logging.error(\"query event error: {}\".format(repr(e)))\n                return None\n\n    def update_event(self, id, job_id, **kwargs):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                job = session.query(AmlEventPool)\\\n                        .filter(AmlEventPool.id == id)\\\n                        .filter(AmlEventPool.job_id == job_id)\\\n                        .one()\n                job.updated_at = datetime.datetime.now()\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in kwargs and kwargs[column.name] is not None:\n                        setattr(job, column.name, kwargs[column.name])\n                session.add(job)\n                session.commit()\n                return True, \"\"\n            except Exception as e:\n                err_msg = \"update job error: {}\".format(repr(e))\n                logging.error(err_msg)\n                return False, err_msg\n            \n    def reset_database(self):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                session.query(AmlEventPool).delete()\n                session.commit()\n                print(\"All job should be deleted\")\n                return True\n            except Exception as e:\n                err_msg = f\"fail to delete {e}\"\n                print(err_msg)\n                return False",
    "dependencies_count": 7,
    "dependencies": [19,20,21,22,23,24,4]
  },
  {
    "index": 19,
    "type": "Function",
    "name": "__init__",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def __init__(self, db_handle):\n        super(AmlEventClient, self).__init__(db_handle)",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 20,
    "type": "Function",
    "name": "_object_as_dict",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def _object_as_dict(obj):\n        obj_dict = {}\n        for column in inspect(obj).mapper.column_attrs:\n            key = column.key\n            value = getattr(obj, column.key)\n            if isinstance(value, datetime.datetime):\n                value = value.strftime(\"%Y-%m-%d %H:%M:%S\")\n            obj_dict[key] = value\n        return obj_dict",
    "dependencies_count": 0,
    "dependencies": []
  },
  {
    "index": 21,
    "type": "Function",
    "name": "insert_event",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def insert_event(self, job_id, component_id, sub_component_id, event_code,\n                    event_description=None,event_data=None, version=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                event = AmlEventPool()\n                event.job_id = job_id\n                event.component_id = component_id\n                event.sub_component_id = sub_component_id\n                event.event_code = event_code\n                event.event_description = event_description\n                event.event_data = json.dumps(event_data or {})\n                event.version = version\n                event.created_at = datetime.datetime.now()\n                event.updated_at = datetime.datetime.now()\n                event.version = version\n                session.add(event)\n                session.commit()\n                return job_id if job_id else event.id, \"\"\n            except Exception as e:\n                err_msg = \"insert event error: {}\".format(repr(e))\n                logging.error(err_msg)\n                return 0, err_msg",
    "dependencies_count": 2,
    "dependencies": [1,4]
  },
  {
    "index": 22,
    "type": "Function",
    "name": "query_events",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def query_events(self, query_dict=None, query_by_desc=False, limit=None):\n        AmlEventPool = self._base.classes.aml_event_pool\n        query_dict = query_dict or {}\n        with self._session_scope() as session:\n            try:\n                matched_event_list = []\n                filters = []\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in query_dict and query_dict[column.name] is not None:\n                        if column.name in [\"created_at\", \"updated_at\"]:\n                            filters.append(and_(column > query_dict[column.name]))\n                        else:\n                            filters.append(and_(column == query_dict[column.name]))\n                query = DBClient(session).select(AmlEventPool, filters)\n                if query_by_desc:\n                    query = query.order_by(desc(AmlEventPool.job_id))\n                if limit:\n                    query = query.limit(limit)\n                for res in query:\n                    matched_event_list.append(self._object_as_dict(res))\n                return matched_event_list\n            except Exception as e:\n                logging.error(\"query event error: {}\".format(repr(e)))\n                return None",
    "dependencies_count": 2,
    "dependencies": [1,4]
  },
  {
    "index": 23,
    "type": "Function",
    "name": "update_event",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def update_event(self, id, job_id, **kwargs):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                job = session.query(AmlEventPool)\\\n                        .filter(AmlEventPool.id == id)\\\n                        .filter(AmlEventPool.job_id == job_id)\\\n                        .one()\n                job.updated_at = datetime.datetime.now()\n                for column in AmlEventPool.__table__.columns:\n                    if column.name in kwargs and kwargs[column.name] is not None:\n                        setattr(job, column.name, kwargs[column.name])\n                session.add(job)\n                session.commit()\n                return True, \"\"\n            except Exception as e:\n                err_msg = \"update job error: {}\".format(repr(e))\n                logging.error(err_msg)\n                return False, err_msg",
    "dependencies_count": 2,
    "dependencies": [1,4]
  },
  {
    "index": 24,
    "type": "Function",
    "name": "reset_database",
    "uri": "/Users/bytedance/Bowen_Yang_SWE/PRIVATE_WORKS/DeepRepo/testing/sample_projects/sample_1_db_client/mysql/event_client.py",
    "code_content": "def reset_database(self):\n        AmlEventPool = self._base.classes.aml_event_pool\n        with self._session_scope() as session:\n            try:\n                session.query(AmlEventPool).delete()\n                session.commit()\n                print(\"All job should be deleted\")\n                return True\n            except Exception as e:\n                err_msg = f\"fail to delete {e}\"\n                print(err_msg)\n                return False",
    "dependencies_count": 2,
    "dependencies": [1,4]
  }
]